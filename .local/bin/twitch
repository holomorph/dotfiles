#!/usr/bin/ruby
# coding: utf-8
# twitch-dmenu.rb
# written by Ogion (on freenode/archforum), inspired by Earnestly (likewise on freenode)
# edited by holomorph (on freenode)

require 'open3'
require 'json'
require 'open-uri'
require 'thread'

def read_config(file)
    array = []
    xdg = ENV["XDG_CONFIG_DIR"]
    dir = xdg ? xdg : File.join(ENV["HOME"], ".config")

    IO.foreach(File.join(dir, "twitch", file)) do |s|
        next if s.chomp.empty? || s.start_with?("#")
        array << s.chomp.strip
    end
    array
end

def get_json(uri)
    JSON.parse(open(uri) {|f| f.read})
rescue => e
    STDERR.puts "#{e.message}: when retrieving #{uri}"
    nil
end

def parse_json(mutex, streams, data, index, owner, uri, title)
    mutex.synchronize do
        data and data[index].each do |s|
            streams << {
                owner: s["channel"][owner], 
                uri:   s["channel"][uri],
                title: s["channel"][title] || '',
            }
        end
    end
end

def get_streams()
    threads = []
    streams = []
    streams_mx = Mutex.new

    teams = read_config("teams")
    users = read_config("streamers")

    teams.each do |team|
        threads << Thread.new do
            data = get_json("http://api.twitch.tv/api/team/#{team}/live_channels.json")
            parse_json(streams_mx, streams, data, "channels", "display_name", "link", "title")
        end
    end

    users.each_slice(100) do |batch|
        threads << Thread.new do
            data = get_json("https://api.twitch.tv/kraken/streams?channel=#{batch.join(",")}&limit=#{batch.count}")
            parse_json(streams_mx, streams, data, "streams", "display_name", "url", "status")
        end
    end

    threads.each(&:join)
    streams
end

def dmenu(items)
    prompt = %W[-p Streams\ (#{items.count})]
    # font = %w[-fn -*-dina-bold-r-*-*-12-*-*-*-*-*-*-*]
    args = %w[-i -l 20] + prompt

    if ENV["DISPLAY"] && !ENV["DISPLAY"].empty? then
        font = %w[-fn Dina\ Bold\ 9]
        cmd = %w[dmenu] + args + font
    else
        cmd = %w[bemenu] + args
    end

    out, status = Open3.capture2(*cmd, stdin_data: items.join("\n"))

    if status.success?
        out.chomp
    else
        nil
    end
end

def play_stream(item)
    title = %Q(#{item[:title]} (#{item[:owner]}))

    pid = fork do
        exec("livestreamer", "-p", "mpv --title=#{title.escape}", item[:uri])
    end
    Process.wait(pid)
end

class String
    def escape
        '"' + self.gsub(/["`\\$]/) { "\\" + $& } + '"'
    end
end

streams = get_streams()

menu = streams.sort_by{|i| "#{i[:owner].downcase}"}
menu = menu.map{|i| "#{i[:owner].ljust(24)} #{i[:title].gsub(/\r?\n/, " ")}"}
sel = dmenu(menu.uniq)

if sel
    threads = []
    results = sel.split(/\r?\n/)
    streams_by_user = Hash[streams.map{|i| [i[:owner], i]}]

    results.each do |name|
        if name =~ /^(\S+)\s+/ and item = streams_by_user[$1]
            threads << Thread.new do
                play_stream(item)
            end
        end
    end

    threads.each(&:join)
end
