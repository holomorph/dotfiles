#!/usr/bin/ruby
# coding: utf-8
# twitch-dmenu.rb
# written by Ogion (on freenode/archforum), inspired by Earnestly (likewise on freenode)
# edited by holomorph (on freenode)

require 'net/http'
require 'open3'
require 'json'
require 'sdbm'
require 'thread'

module Twitch
  API = "https://api.twitch.tv/kraken"
  API_TYPE = 'application/vnd.twitchtv.v5+json'
  CLIENT_ID = "jzkbprff40iqj646a697cyrvl0zt2m6"
end

class Hash
  def display_s(just)
    name = self.dig("display_name").ljust(just)
    title = self.dig("status").gsub(/\r?\n/, " ")
    "#{name}#{title} [#{self.dig("game")}]"
  end
end

class String
  def escape
    '"' + self.gsub(/["`\\$]/) { "\\" + $& } + '"'
  end
end

def xdg_config_twitch(name)
  xdg = ENV["XDG_CONFIG_DIR"]
  dir = xdg ? xdg : File.join(ENV["HOME"], ".config")
  File.join(dir, "twitch", name)
end

def parse_config(file)
  array = []
  IO.foreach(file) do |s|
    next if s.chomp.empty? || s.start_with?("#")
    array << s.chomp.strip
  end
  array
end

def request(url)
  uri = URI(url)
  res = Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
    req = Net::HTTP::Get.new(uri)
    req['Client-ID'] = Twitch::CLIENT_ID
    req['Accept'] = Twitch::API_TYPE
    http.request(req)
  end
  res.body
rescue => e
  warn format("When retrieving %s\n%s", url, e.message)
end

def get_streams()
  threads = []
  streams = []
  streams_mx = Mutex.new
  file = xdg_config_twitch("streamers")
  users = parse_config(file)
  db = SDBM.new(file)

  case (olddb = File.mtime(file) > File.mtime("#{file}.pag"))
  when false
    olddb = true if db.empty?
  when true
    db.clear unless db.empty?
  end

  users.each_slice(100) do |batch|
    threads << Thread.new do
      streams_mx.synchronize do
        ids = []
        if olddb
          url = "#{Twitch::API}/users?login=#{batch.join(",")}"
          data = JSON.parse(request(url))
          data.dig("users").each do |s|
            id = s.dig("_id")
            name = s.dig("name")
            # must use names as they appear in the config
            db[batch.find{|n| name =~ /#{n.downcase}/}] = id
            ids << id
          end
        else
          batch.each do |user|
            ids << db[user]
          end
        end

        url = "#{Twitch::API}/streams?channel=#{ids.join(",")}"
        data = JSON.parse(request(url))
        data.dig("streams").each do |s|
          streams << s.dig("channel")
        end
      end
    end
  end

  threads.each(&:join)
  db.close unless db.closed?
  streams
end

def dmenu(items)
  prompt = %W[-p Streams\ (#{items.count})]
  # font = %w[-fn -*-dina-bold-r-*-*-12-*-*-*-*-*-*-*]
  font = "DejaVu Sans Mono"
  args = %w[-i -l 20] + prompt

  if ENV["DISPLAY"] && !ENV["DISPLAY"].empty?
    cmd = %w[dmenu] + args + %W[-fn #{font}]
  else
    cmd = %w[bemenu] + args + %W[--fn #{font}]
  end

  out, status = Open3.capture2(*cmd, stdin_data: items.join("\n"))
  status.success? ? out.chomp : nil
end

def play_stream(item)
  title = %Q(#{item["status"]} (#{item["display_name"]}))
  uri = item[:uri] || "http://twitch.tv/#{item["name"]}"

  pid = fork do
    exec("mpv", "--title", title, uri)
  end
  Process.wait(pid)
end

def play_selected(sel, streams)
  threads = []

  sel.split(/\r?\n/).each do |name|
    if item = streams.find{|i| name =~ /^#{i["display_name"]}/}
      threads << Thread.new do
        play_stream(item)
      end
    end
  end

  threads.each(&:join)
end

streams = get_streams()
unless streams.empty?
  width = streams.map{|i| i.dig("display_name").length}.max + 4
  menu = streams.uniq{|i| i.dig("name")}.sort_by{|i| i.dig("name")}
  menu = menu.map{|i| i.display_s(width) }
  sel = dmenu(menu)
  play_selected(sel, streams) if sel
end
