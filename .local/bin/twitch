#!/usr/bin/ruby
# coding: utf-8
# twitch-dmenu.rb
# written by Ogion (on freenode/archforum), inspired by Earnestly (likewise on freenode)
# edited by holomorph (on freenode)

require 'net/http'
require 'open3'
require 'json'
require 'thread'

module Twitch
    V2 = {index: "channels", owner: "display_name", uri: "link", title: "title"}
    V3 = {index: "streams", owner: "display_name", url: "url", title: "status"}
end

def read_config(file)
    array = []
    xdg = ENV["XDG_CONFIG_DIR"]
    dir = xdg ? xdg : File.join(ENV["HOME"], ".config")

    IO.foreach(File.join(dir, "twitch", file)) do |s|
        next if s.chomp.empty? || s.start_with?("#")
        array << s.chomp.strip
    end
    array
end

def get_json(uri)
    JSON.parse(Net::HTTP.get(URI(uri)))
rescue => e
    warn format("When retrieving %s\n%s", uri, e.message)
end

def parse_json(streams, data, keys)
    data and data[keys[:index]].each do |s|
        streams << {
            owner: s["channel"][keys[:owner]],
            uri:   s["channel"][keys[:uri]],
            title: s["channel"][keys[:title]] || '',
        }
    end
end

def get_streams()
    threads = []
    streams = []
    streams_mx = Mutex.new

    teams = read_config("teams")
    users = read_config("streamers")

    teams.each do |team|
        threads << Thread.new do
            streams_mx.synchronize do
                url = "http://api.twitch.tv/api/team/#{team}/live_channels.json"
                data = get_json(url)
                parse_json(streams, data, Twitch::V2)
            end
        end
    end

    users.each_slice(100) do |batch|
        threads << Thread.new do
            streams_mx.synchronize do
                url = format("https://api.twitch.tv/kraken/streams?channel=%s&limit=%d",
                             batch.join(","), batch.count)
                data = get_json(url)
                parse_json(streams, data, Twitch::V3)
            end
        end
    end

    threads.each(&:join)
    streams
end

def dmenu(items)
    prompt = %W[-p Streams\ (#{items.count})]
    # font = %w[-fn -*-dina-bold-r-*-*-12-*-*-*-*-*-*-*]
    args = %w[-i -l 20] + prompt

    if ENV["DISPLAY"] && !ENV["DISPLAY"].empty?
        font = %w[-fn Dina\ Bold\ 9]
        cmd = %w[dmenu] + args + font
    else
        cmd = %w[bemenu] + args
    end

    out, status = Open3.capture2(*cmd, stdin_data: items.join("\n"))
    status.success? ? out.chomp : nil
end

def play_stream(item)
    title = %Q(#{item[:title]} (#{item[:owner]}))
    uri = item[:uri] || "http://twitch.tv/#{item[:owner]}"

    pid = fork do
        exec("livestreamer", "-p", "mpv --title=#{title.escape}", uri)
    end
    Process.wait(pid)
end

class String
    def escape
        '"' + self.gsub(/["`\\$]/) { "\\" + $& } + '"'
    end
end

streams = get_streams()
menu = streams.uniq{|i| i[:owner]}.sort_by{|i| "#{i[:owner].downcase}"}
menu = menu.map{|i| "#{i[:owner].ljust(24)} #{i[:title].gsub(/\r?\n/, " ")}"}
sel = dmenu(menu)

if sel
    threads = []

    sel.split(/\r?\n/).each do |name|
        if item = streams.find{|i| name =~ /^#{i[:owner]}/}
            threads << Thread.new do
                play_stream(item)
            end
        end
    end

    threads.each(&:join)
end
