#!/usr/bin/ruby
# coding: utf-8
# twitch-dmenu.rb
# written by Ogion (on freenode/archforum), inspired by Earnestly (likewise on freenode)
# edited by holomorph (on freenode)

require 'net/http'
require 'open3'
require 'json'
require 'thread'

module Twitch
  API = "https://api.twitch.tv/kraken"
  CLIENT_ID = "jzkbprff40iqj646a697cyrvl0zt2m6"
end

class Hash
  def display_s(just)
    self.dig("display_name").ljust(just) + self.dig("status").gsub(/\r?\n/, " ")
  end
end

class String
  def escape
    '"' + self.gsub(/["`\\$]/) { "\\" + $& } + '"'
  end
end

def read_config(file)
  array = []
  xdg = ENV["XDG_CONFIG_DIR"]
  dir = xdg ? xdg : File.join(ENV["HOME"], ".config")

  IO.foreach(File.join(dir, "twitch", file)) do |s|
    next if s.chomp.empty? || s.start_with?("#")
    array << s.chomp.strip
  end
  array
end

def request(url)
  uri = URI(url)
  res = Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
    req = Net::HTTP::Get.new(uri)
    req['Client-ID'] = Twitch::CLIENT_ID
    http.request(req)
  end
  res.body
rescue => e
  warn format("When retrieving %s\n%s", url, e.message)
end

def get_streams()
  threads = []
  streams = []
  streams_mx = Mutex.new

  users = read_config("streamers")

  users.each_slice(100) do |batch|
    threads << Thread.new do
      streams_mx.synchronize do
        url = "#{Twitch::API}/streams?channel=#{batch.join(",")}" +
              "&limit=#{batch.count}"
        data = JSON.parse(request(url))
        data.dig("streams").each do |s|
          streams << s.dig("channel")
        end
      end
    end
  end

  threads.each(&:join)
  streams
end

def dmenu(items)
  prompt = %W[-p Streams\ (#{items.count})]
  # font = %w[-fn -*-dina-bold-r-*-*-12-*-*-*-*-*-*-*]
  font = "DejaVu Sans Mono"
  args = %w[-i -l 20] + prompt

  if ENV["DISPLAY"] && !ENV["DISPLAY"].empty?
    cmd = %w[dmenu] + args + %W[-fn #{font}]
  else
    cmd = %w[bemenu] + args + %W[--fn #{font}]
  end

  out, status = Open3.capture2(*cmd, stdin_data: items.join("\n"))
  status.success? ? out.chomp : nil
end

def play_stream(item)
  title = %Q(#{item["status"]} (#{item["display_name"]}))
  uri = item[:uri] || "http://twitch.tv/#{item["name"]}"

  pid = fork do
    exec("mpv", "--title", title, uri)
  end
  Process.wait(pid)
end

def play_selected(sel, streams)
  threads = []

  sel.split(/\r?\n/).each do |name|
    if item = streams.find{|i| name =~ /^#{i["display_name"]}/}
      threads << Thread.new do
        play_stream(item)
      end
    end
  end

  threads.each(&:join)
end

streams = get_streams()
unless streams.empty?
  width = streams.map{|i| i.dig("display_name").length}.max + 4
  menu = streams.uniq{|i| i.dig("name")}.sort_by{|i| i.dig("name")}
  menu = menu.map{|i| i.display_s(width) }
  sel = dmenu(menu)
  play_selected(sel, streams) if sel
end
